<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="refresh" content="1800">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meshtastic Matrix Map</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />
    
    <style>
        body { margin: 0; background: #000; font-family: 'Segoe UI', sans-serif; overflow: hidden; }
        #map { height: 100vh; width: 100%; background: #111; }
        
        /* Mappa scura stile Matrix */
        .leaflet-tile-pane { filter: contrast(1.1) brightness(1.1); }
        
        /* Cursore sulle linee */
        .leaflet-interactive { cursor: pointer; }

        /* Stile Icona Nodo */
        .node-pin {
            display: flex; justify-content: center; align-items: center; position: relative;
            border-radius: 50%; border: 2px solid #fff; color: #000; font-weight: 900; font-size: 9px;
            box-shadow: 0 0 10px rgba(0,0,0,0.8); cursor: pointer; transition: transform 0.1s;
        }
        .node-pin:hover { transform: scale(1.4); z-index: 10000; box-shadow: 0 0 20px #fff; }
        
        /* Animazione MQTT (Blu/Verde) */
        @keyframes mqtt-pulse {
            0% { background-color: #0088FF; box-shadow: 0 0 6px #0088FF; }
            50% { background-color: #00FF00; box-shadow: 0 0 10px #00FF00; }
            100% { background-color: #0088FF; box-shadow: 0 0 6px #0088FF; }
        }
        .mqtt-badge {
            position: absolute; top: -3px; right: -3px;
            width: 10px; height: 10px; border-radius: 50%;
            border: 1px solid #fff; z-index: 10;
            animation: mqtt-pulse 1.5s infinite linear;
        }
        .mqtt-badge-static {
            display: inline-block; width: 10px; height: 10px; border-radius: 50%;
            margin-right: 5px; animation: mqtt-pulse 1.5s infinite linear;
        }

        /* Popup Info */
        .leaflet-popup-content-wrapper { background: rgba(10, 10, 10, 0.95); border: 1px solid #666; color: #ddd; font-size: 11px; }
        .leaflet-popup-tip { background: #333; }
        .leaflet-popup-close-button { color: #fff !important; }

        .info-table { width: 100%; border-collapse: collapse; margin-top: 5px; }
        .info-table td { padding: 3px 0; border-bottom: 1px solid #333; }
        .val { color: #fff; font-weight: bold; text-align: right; }
        
        .dist-badge { background: #000; border: 1px solid #fff; color: #fff; padding: 2px 8px; border-radius: 10px; font-size: 11px; white-space: nowrap; }
        .hud { position: absolute; top: 15px; left: 50%; transform: translateX(-50%); z-index: 1000; background: rgba(0,0,0,0.8); border: 1px solid #00FF00; padding: 5px 25px; color: #00FF00; font-weight: bold; border-radius: 50px; pointer-events: none; }
    </style>
</head>
<body>
    <div class="hud">MATRIX LIVE MAP</div>
    <div id="map"></div>
    
    <script>
        // === 1. CONFIGURAZIONE E VARIABILI GLOBALI ===
        let rawNodes = []; // Dati dinamici
        let rawEdges = []; // Dati dinamici
        
        // Inizializzazione Mappa
        const map = L.map('map', {
            center: [42.5, 12.5], // Centro Italia approssimativo
            zoom: 6,
            zoomControl: false,
            attributionControl: false
        });
        
        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
            maxZoom: 19
        }).addTo(map);

        // Gruppo Markers (Definito globalmente per poterlo pulire)
        const markers = L.markerClusterGroup({
            maxClusterRadius: 40,
            spiderfyOnMaxZoom: true,
            showCoverageOnHover: false,
            zoomToBoundsOnClick: true,
            // Stile personalizzato cluster (opzionale, mantiene default scuro)
        });
        map.addLayer(markers);

        // Variabili di stato per l'interazione
        let activeNodeId = null;
        let activeLines = [];
        let clickStage = 0; // 0: Nessuno, 1: Info Popup, 2: Linee Connessione

        // === 2. FUNZIONI UTILITY ===
        
        // Pulisce le linee di connessione e i badge distanza
        function clearLines() {
            activeLines.forEach(layer => map.removeLayer(layer));
            activeLines = [];
        }

        // Determina il colore del nodo in base al ruolo
        function getColor(node) {
            // Esempio logica colori: Router=Verde, Client=Blu, Altro=Grigio/Bianco
            if (!node.role) return '#fff';
            if (node.role.includes('ROUTER')) return '#00FF00';
            if (node.role.includes('CLIENT')) return '#0088FF';
            if (node.role.includes('TRACKER')) return '#FF00FF';
            return '#fff';
        }

        // Determina il colore della linea in base all'SNR
        function getLineColor(snr) {
            if (snr >= 5) return '#00FF00'; // Ottimo
            if (snr >= 0) return '#ADFF2F'; // Buono
            if (snr >= -10) return '#FFA500'; // Medio
            return '#FF0000'; // Scarso
        }

        // === 3. LOGICA PRINCIPALE DI RENDERING ===
        function initMatrix() {
            // PULIZIA: Rimuovi vecchi marker e linee prima di ridisegnare
            markers.clearLayers();
            clearLines();
            activeNodeId = null;
            clickStage = 0;

            console.log("Rendering mappa con " + rawNodes.length + " nodi.");

            rawNodes.forEach(node => {
                // Salta nodi senza posizione valida
                if (!node.last_position || !node.last_position.latitude || !node.last_position.longitude) return;

                const lat = parseFloat(node.last_position.latitude);
                const lng = parseFloat(node.last_position.longitude);
                
                // Creazione Icona HTML
                const color = getColor(node);
                const isMqtt = node.has_mqtt ? '<div class="mqtt-badge"></div>' : '';
                const iconHtml = `<div class="node-pin" style="border-color:${color}; background:rgba(0,0,0,0.5);">
                                    ${node.short_name || '?'}
                                    ${isMqtt}
                                  </div>`;
                
                const customIcon = L.divIcon({
                    className: 'custom-div-icon', // Classe vuota per evitare stili default Leaflet fastidiosi
                    html: iconHtml,
                    iconSize: [40, 40],
                    iconAnchor: [20, 20]
                });

                const marker = L.marker([lat, lng], { icon: customIcon });

                // Gestione Click (Logica 3-Step)
                marker.on('click', function(e) {
                    // Se clicco su un nodo diverso, resetto
                    if (activeNodeId !== node.id) {
                        clearLines();
                        clickStage = 1;
                        activeNodeId = node.id;
                        
                        // Contenuto Popup
                        const voltage = node.last_device_metric ? node.last_device_metric.battery_voltage : 'N/A';
                        const battery = node.last_device_metric ? node.last_device_metric.battery_level + '%' : 'N/A';
                        const lastHeard = new Date(node.last_heard).toLocaleString();
                        
                        const popupContent = `
                            <div style="min-width:200px">
                                <h3 style="color:${color}; margin:0 0 5px 0;">${node.long_name}</h3>
                                <div style="font-size:10px; color:#aaa; margin-bottom:10px;">${node.id}</div>
                                <table class="info-table">
                                    <tr><td>Role</td><td class="val">${node.role}</td></tr>
                                    <tr><td>Hardware</td><td class="val">${node.hardware}</td></tr>
                                    <tr><td>Batt/Volt</td><td class="val">${battery} / ${voltage}V</td></tr>
                                    <tr><td>Last Heard</td><td class="val">${lastHeard}</td></tr>
                                </table>
                                <div style="margin-top:10px; font-size:10px; text-align:center; color:#888;">
                                    Clicca ancora per le connessioni
                                </div>
                            </div>
                        `;
                        
                        marker.bindPopup(popupContent, { autoPan: true }).openPopup();

                    } else {
                        // === STESSO NODO (Logica sequenziale) ===
                        if (clickStage === 1) {
                            // Secondo Click: Mostra Linee
                            clickStage = 2;
                            marker.closePopup();
                            marker.unbindPopup(); // Rimuovo popup per evitare riapertura immediata
                            
                            // Disegna Linee
                            // Filtra edges dove questo nodo è sorgente o destinazione
                            const links = rawEdges.filter(edge => 
                                (edge.node_src && edge.node_src.id === node.id) || 
                                (edge.node_dst && edge.node_dst.id === node.id)
                            );

                            links.forEach(edge => {
                                // Trova coordinate dell'altro nodo
                                const otherNodeId = (edge.node_src.id === node.id) ? edge.node_dst.id : edge.node_src.id;
                                const otherNode = rawNodes.find(n => n.id === otherNodeId);

                                if (otherNode && otherNode.last_position && otherNode.last_position.latitude) {
                                    const otherLat = otherNode.last_position.latitude;
                                    const otherLng = otherNode.last_position.longitude;
                                    
                                    const lineColor = getLineColor(edge.snr);
                                    
                                    // Disegna linea
                                    const polyline = L.polyline([[lat, lng], [otherLat, otherLng]], {
                                        color: lineColor,
                                        weight: 2,
                                        opacity: 0.6,
                                        dashArray: '5, 10'
                                    }).addTo(map);
                                    activeLines.push(polyline);

                                    // Badge Distanza/SNR a metà linea
                                    const midLat = (parseFloat(lat) + parseFloat(otherLat)) / 2;
                                    const midLng = (parseFloat(lng) + parseFloat(otherLng)) / 2;
                                    const distKm = (edge.distance / 1000).toFixed(1);
                                    
                                    const badgeHtml = `<span style="color:${lineColor}">${edge.snr}dB</span> | ${distKm}km`;
                                    const badgeIcon = L.divIcon({
                                        className: 'dist-badge',
                                        html: badgeHtml,
                                        iconSize: [80, 18],
                                        iconAnchor: [40, 9]
                                    });
                                    
                                    const badgeMarker = L.marker([midLat, midLng], { icon: badgeIcon, interactive: false }).addTo(map);
                                    activeLines.push(badgeMarker);
                                }
                            });

                        } else {
                            // Terzo Click: Chiudi tutto
                            clickStage = 0;
                            activeNodeId = null;
                            clearLines();
                        }
                    }
                });

                markers.addLayer(marker);
            });
        }

        // Gestione Click Vuoto sulla mappa per resettare
        map.on('click', function(e){ 
            // Verifica che non si stia cliccando su un marker o popup
            if(e.originalEvent.target === map.getContainer()) {
                clearLines();
                map.closePopup();
                activeNodeId = null;
                clickStage = 0;
            }
        });

        // === 4. FETCH DATI E AGGIORNAMENTO AUTOMATICO ===
        async function updateData() {
            console.log("Aggiornamento dati Matrix in corso...");
            try {
                // Download parallelo di Nodi e Archi
                const [nodesResponse, edgesResponse] = await Promise.all([
                    fetch('https://api.loraitalia.it/public/map/get/nodes'),
                    fetch('https://api.loraitalia.it/public/map/get/edges')
                ]);

                if (!nodesResponse.ok || !edgesResponse.ok) throw new Error("Errore HTTP durante il download");

                // Aggiornamento variabili
                rawNodes = await nodesResponse.json();
                rawEdges = await edgesResponse.json();

                console.log(`Dati ricevuti: ${rawNodes.length} nodi, ${rawEdges.length} connessioni.`);

                // Ridisegna la mappa
                initMatrix();

            } catch (error) {
                console.error("Errore aggiornamento Matrix:", error);
                // Riprova tra 1 minuto se fallisce
                setTimeout(updateData, 60000); 
            }
        }

        // Avvio iniziale
        updateData();

        // Imposta timer: aggiorna ogni 10 minuti (600.000 ms)
        setInterval(updateData, 600000);

    </script>
</body>
</html>